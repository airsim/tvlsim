
\documentclass[11pt]{JHEP3} 
 
\pagestyle{plain}
 
\usepackage{amsmath} 
\usepackage{amsthm} 
\usepackage{amsfonts} 
%\usepackage{algorithmic}
\usepackage{graphicx} 

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc} %% utf8 est la manière standard d'encoder
                            %% les caractère; standard sous linux,
                            %% évidemment ... sous mac je ne sais pas
                            %% ..
\usepackage[francais]{babel} %% Eh, parlons français !! 
%\usepackage[Latin1]{inputenc} 
  
%%%%%%%%%%%%% Dimensionnement : si tu veux régler les marges à la
%%%%%%%%%%%%% main, car le style global est amsart, ce qui est très
%%%%%%%%%%%%% ... américain
 
%\topmargin 0.5cm 
%\headsep 5.mm 
%\textheight 22.5cm % Autrefois 22cm 
%\textwidth 16.5cm 
%\oddsidemargin -0.2cm 
%\evensidemargin -0.2cm 
 
%% Attaquons le vif du sujet ! 
 
\title{Simule moi un avion} 
\author{William Le Ferrand} 


\abstract{ At Ecole Polytechnique, we were taught a lot of computer
  science. How do these skills apply to real world? My internship
  at Amadeus gave me the opportunity to confront with compelling
  projects and to get introduced to professional software design.  }

\begin{document}
\maketitle 
\newpage

\section{Context}

The 6th of April I joined the DEV-ORI\footnote{Operation Research and
  Innovation division} at Amadeus, in Sophia Antipolis, on the French
Riviera. I came here because I had the opportunity to discover this
company in October and had met several enthusiast members of the
DEV-ORI team.

For almost two years, DEV-ORI has been focusing on
Asim\footnote{Amadeus Simulator}/Latus, a \textbf{Leisure and Travel
  Oriented Discrete-Event Simulation} engine. They came up with a
working implementation of several expert algorithms for modelling user
behaviour, airlines strategies and market events, a modular 100,000+
lines of C++ program.

In terms of features, Asim/Latus already challenges PODS, the MIT
simulator, a reference in this field. Nevertheless, for Asim/Latus to
become the most widespread airline simulation suite, DEV-ORI still
needed to improve the efficiency and scalabilty of its simulator.

\subsection{About Amadeus}

Amadeus specialises in travel technology solutions to facilitate the
distribution and sale of airline, train, cruise ship, rental car,
hotel and other travel services. The traditional core of its business
is the Amadeus Global Distribution System (GDS); more recently the
company has tried to reposition itself as an IT partner for the travel
and tourism industries, offering e-commerce and IT services in
addition to its distribution business.

Amadeus research center is located in Sophia Antipolis while the group
has offices in Miami, USA, Bangkok, Thailand and Erding,
Germany. There are also IT services centres in London, UK, and Sydney,
Australia.

It is the first time that I am confronted with such an organisation,
where every single project requires dozens of engineers and where
decisions are taken in a long-term view. No doubt, being part of
DEV-ORI is not a one day task, and I would need severaly weeks to get
familiar with both Amadeus tools and its corporate technology strategy.

\subsection{About Latus}


The main objective of Asim/Latus is to benchmark revenue management algorithms. 

\paragraph{What is revenue management ?} Let's quote the image given by the revenue management gurus Kalyan Talluri and Garrett van Ryzin:

\begin{quote}
A child selling limonade outside her house has to decide on which day
to have her sale, how much to ask for each cup, and when to drop the
price (if at all) as the days rolls on. A homeowner selling a house
must decide when to list it, what the asking price should be, which
offer to accept, and when to lower the listing price if no offers come
in. A stamp dealer selling on an Internet auction site has to select
the duration of the auction, what reserve price to set.
\end{quote} 

Revenue management mechanisms are tighly related to uncertainty and
try to design algorithms to address three types of decisions:

\begin{itemize}
\item Structural decisions: which selling format to use, which terms
  trade to offer. In the airline field, it may include refund options,
  volume discounts and so on.
\item Price decisions: how to set posted prices, how to price accross
  categories. Every traveller knows how fast plane ticket prices
  evolves over time!
\item Quantity decisions: when to accept or reject an offer to buy,
  how to allocate capacity. This includes the opening and closing of
  cabin classes for instance.
\end{itemize}

Airlines heavily rely on revenue management to maximize their profit
because the market has become very competitive and a loss of a few
euros on a single ticket might mean the bankrupt of the company.

As market strategies can not be directly tested in a production context,
airlines need a simulator to benchmark and tune up their
strategies. Here comes Asim/Latus: this simulator is capable to perform
almost all the operations that occur on the airline market,
sequentially, and is thus the ideal tool for airline analysts.


\FIGURE{
\label{flow}
\includegraphics[height=60mm]{simflow.jpg}
\caption{Booking flow into the simulator}
}

\paragraph{Latus cycle}

Asim/Latus simulates every event that occur in a booking transaction, from
issuing the booking request to updating tickets prices according to
the number of seats available.

As shown on figure \ref{flow}, \textbf{booking requests} are generated
according to a probability distribution inferred from real life
datasets. Then, \textbf{travel solutions} that satisfy to this request
are computed based on flight schedule and seat availabilities. A
\textbf{fare} is attached to each travel solution according to the
airline-specific revenue management strategies. These travel solutions
are processed by a \textbf{customer choice module (CCM)} to select a best
solution according to the customer preferences. Finally the booking
is taken into account by the \textbf{inventory} module of the
corresponding airline.


\newpage
\section{Tame Latus}

\subsection{A multi-user GUI}

Asim/Latus comes with a command line interface, which might be practical for
some people but not as glamorous as a user-friendly graphical user
interface (GUI). At the beginning of my internship I was asked to write such
a GUI, which happened to be a very good exercice to get familiar with
Asim/Latus.

\FIGURE{
\includegraphics[width=400px]{gui.jpeg}
\caption{Functionnal architecture of Asim/Latus GUI}
}

\subsection{Requested features}

The mandatory features include:

\begin{itemize}
\item Input management (storing the input files in a database, check
  the integrity)
\item Batch processing (Asim/Latus needs time, so it is more
  convenient to receive an email when the simulation is completed
  rather than to wait in front of the screen)
\item Users profile: we want to store user preferences to avoid
  retyping the database password everytime for instance.
\end{itemize}

\subsection{OCaml rocks}

In 2007 I set up a Web Service, called Halix; it was roughly an image
indexer over Flickr. It had a front end written in OCaml based on the
framework Ocsigen\footnote{www.ocsigen.org}, and to cope with the
intensive needs for computing power the middleware was written in a
distributed fashion using JoCaml\footnote{jocaml.inria.fr}. I decided
to keep using theses tools to build Asim/Latus GUI.

\par Thus, the GUI relies on a pool of JoCaml agents. Jocaml agents
are programs lauched accross the network that register to the
middleware and expose some functions of the simulator (mainly
\texttt{getConfiguration} and \texttt{run}). They are linked against
Latus through a C program that performs data conversion (and that
registers values to the GC).

\par This pool of agents is itself dynamically linked to the Ocsigen
Web Server (thanks to the natdynlink features of (J)ocaml 3.11.x) and
the command functions are exposed over ajax connectors.

\par The GUI itself is a set of OCaml programs that are lauched on
client side through O'Browser, an OCaml virtual machine written in
javascript that I've modified to support JSON
communications\footnote{I wrote this extended version of OBrowser for
  use in www.beouifi.org managers, to allow cross domain communication
  and thus overcome this javascript limitation}.

This is how we get an efficient and light GUI for Latus written in a
single powerful language, OCaml.

\FIGURE{
\includegraphics[width=300px]{guiscreen.png}
\caption{GUI screenshot}
}
\newpage

\section{Profiling LATUS}

To run a one year simulation on a network of two airlines and two
flights per airline, 6 classes per flight, Latus needs several
days. Why?

If we examinate in detail the way Latus runs, we discover that the
most resource consuming module is the \textbf{forecaster}.

\subsection{The forecaster}

The forcaster is a piece of code which is called every day at midnight
(simulated time) and that is responsible for guessing the booking
request distribution for future time, in order to allow the airline to
adjust the fares and maximize its revenue.

The forcaster handles a specific structure, the \textbf{guillotine}. A
guillotine is attached to each pair (flight\_number, class\_code) and
stores the numbers of bookings for each flight at each step of the
simulation.

\FIGURE{
  \label{guillotine}
  \caption{A guillotine at date 20-APR-09 (columns are days to departure)}
  \begin{tabular}{c|ccccc}
               & 365 & 364 & ... & 1  & 0 \\
    \hline 
  20-APR-2009  &  0  &  2  & ...   & 12 & 5 \\
  ... \\          
  18-APR-2010  &  1  &  8  & ...   & - &  - \\
  19-APR-2010  &  2  &  3  & ...  & - &  - \\
  20-APR-2010  &  1  &  -  & ...  & - &  - \\
  \end{tabular}
  
}

An example of such a guillotine is given on figure
\ref{guillotine}. It's a snapshot taken the 20th of April 2009. As
flights are open to reservation one year before their departure date,
there is already a booking counter for the flight for the 20th of
April 2009. We see that the guillotine stores for each flight\_date
the numbers of bookings issued for each day before departure.

The core assumption is that the demand generated n days before
departure for the flight that will take off at date d is related to
the demand generated n days before departure for the previous
flights. Thus, there are serveral algorithms workings on the columns
on the guillotine and trying to guess the future bookings counters :
this is the forecasting.

dSim implements a basic algorithm that averages the values on a
sliding windows. While this algorithm is naive, it is used in
production and it is enough resources consuming to get real figures
when benchmarking dSim against Latus. Moreover, the point here is not
to implement a specific algorithm but rather to specifiy an API that
would allow airline analysts to implement their own forecasting engine
at no cost.

\paragraph{The memory issue}

As you can imagine, storing the guillotines requires a large amount of
memory. To overcome the standard memory limitation and because it was
handful for further uses of the booking counters, the team decided to
store the data in a MySQL database.

Unfortunately, inserting and selecting data from such a database is
much slower than using a all-in-memory solution.

I ran several tests to benchmark the performances of several MySQL
flavors (mysqld 5.3, mysqld 6.0 and libmysqld, an embedded mysql
server).

I also benchmarked memcached solutions, but the performances were
desappointing.

No doubt: to get a fast, efficient and scalable simulator, we had to
rewrite it in a \textbf{distributed} fashion.

\section{dSim: a JoCaml prototype}

To set up a clear API, I wrote a prototype using the JoCaml
language. It allowed to see clearly how inter process communication
were to be written and to get the first benchmark figures.

The architecture is quite simple: a main program processes the inputs
and dispatch the flights accross available computing clients. Clients
are to store the guillotine and forecast.

In this scheme, booking requests are generated on the main process and
are sent to the relevant client. Then, at mignight, a forecasting
signal is sent to all the agents \textbf{in parallel}.

JoCaml is a fantastic language to implement the prototype: it allows
fast programming (especially thanks to the strong typing mechanism)
and produce rather efficient binaries, thus giving some insights on
the performance gain.

The source code is presented in the appendix.

\section{dSim: a MPI C implementation}

Once the global architecture was set up, we decided to implement it in
the most efficient way. To achieve that, I wrote a basic simulator in
C, relying on the MPI standard for interprocess communication and on
an heavy preprocessing on the imputs to turn all the data structures
into arrays, allocated once of all at the beginning of the simulation.

It is far the most intersting part of my internship, so I suggest we
walk together accross the different steps toward such a distributed
toy simulator.

\subsection{MPI architecture}

MPI, the Message Passing Interface, is the main industry standard for
data exchanges in distributed programming. Its widely supported by
many resources managers and task schedulers, so deploying a MPI
application is rather easy.

In the MPI paradigm, the same piece of software is launched several
times and get a unique identifier (the rank). The behavior of the code
depends of this identifier.

For our purpose, there will be two flavors of instances :

\begin{itemize}
\item Master: the process with rank 0. It will be responsible for
  administrative tasks (retrieving the inputs, preprocessing and
  splitting among slaves) and demand generation.
\item Slave : the process with rank $r > 0$. They will handle the
  guillotines and process the forecast.
\end{itemize}

We will link against the MPICH implementation of MPI (the messages are
based on a push mechanism), but dSim compiles with any other MPI
implementation such as OpenMPI (poll mechanism, more CPU intensive in
our case), of course.

\subsection{Listening to the inputs}

Are we are planning to launch dSim in a cluster, we don't want to rely
on the filesystem for the inputs. The most convenient way is to write
a text protocol for feeding dSim with its inputs.

There are a few parameters that have to be provided for the simulation
to run properly.

\paragraph{Simulation parameters} We have to set the 

\begin{itemize}
\item rid: replication id, an integer used to track the current simulation
\item to\_bi: boolean value indicating whether the guillotines are to
  be flushed to mysql or not
\item duration: number of simulated days
\end{itemize}

\paragraph{Simulation inputs} We need to get the schedule, the list of the flights all over the world. A flight will be characterized by 

\begin{itemize}
\item origin
\item destination
\item airline\_code
\item flight\_number
\item first date of departure
\item last date of departure
\item departure time
\item arrival time
\item number of classes
\end{itemize}

We also need to specify the demand. Thus, for each pair
origin-destination (OnD), we specify the average number of bookings
per day and the departure day distribution. For instance, \texttt{add
  demand NCE LHR 50 10 5 15 90 30 100} means that for the OnD NCE LHR
there are in average 50 bookings per day and that 10 percent of the
people who book a flight decide to fly between 5 and 15 days after the
booking date.

Here is an example of an interactive session:

\begin{verbatim}
set rid 1
set duration 365
set to_bi 1
add flight NCE LHR AF 448 0 100 0 12 5
add demand NCE LHR 50 10 5 15 90 30 100
run
\end{verbatim}


\subsection{Preprocessing the inputs}

The demand is processed to create all the travel solutions you can
imagine, based on the fact that a travel solution has at most 3
hops. The resulting chained structure is then converted to an
array-based structure for efficiency sake.

Then, we build a translation table for the schedule: each
flight/class\_code is assigned to a slave and gets a new id (to have
continuous addressing on the slave side too).

\subsection{Initializing the slaves}

It is time to send to each slave the number of guillotines it will have
to handled. As we already know the simulation duration, we can
allocate all the memory that will be needed for the guillotines. (It
prevents memory exhaution during the simulation). Once again, we only
use arrays as data structures.

\subsection{Running the simulation}

Running the simulation means roughly going through the OnDs and
randomly generating booking requests, then sending the booking request
to the relevant slave. Each day at midnight, a signal is sent to all
the agent to tell them to process the forecast.

\subsection{Dumping the output}

Depending whether this option is selected or not, the guillotines'
content can be (asynchronously) sent to a mysql database for later use
by the business intelligence tools. The implementation takes advantage
of MySQL prepared requests, a kind of binary protocol that minimize
the overhead. This choice has been made after a series of benchmark of
the different MySQL flavors and API that I've released on my blog,
Well-Tempered Keyboard. (http://welltemperedkeyboard.blogspot.com/)


\subsection{dSim performance}

We are currently setting up a cluster to benchmark the mpi C
simulator, but on my machine it is approximatively 100x faster than
Asim/Latus.

For sure, this is partly due to the fact that dSim is much simpler
than Latus, but no doubt that constant-access time data structures and
the fact that the load is distributed on two cores also play a key
role in the overall speed up.


\FIGURE{
\includegraphics[width=400px]{agenttime.jpg}
\caption{Booking request processing time in Latus}
}

The complexity is also improved: booking requests are no processed in
constant time rather than in logarithmic time (by respect to the
date). This is due to the move from maps to arrays.


\FIGURE{
\includegraphics[width=400px]{newsaletime.jpg}
\caption{Booking request processing time in dSim}
}

\subsection{Source Code}

I have spend a lot of time to come up with working implentation of
testing programs as well as dSim. The JoCaml prototype and the C
implementation are both available on SourceForge, at this address:

\begin{tabular}{c}
https://sourceforge.net/projects/dsim/
\end{tabular}

\newpage
\section{Conclusion}

It is quite impossible to conclude right now because I am going to
spend another six weeks at Amadeus, but I can already compare this
experience with my previous internship.

During the last few years I had the opportunity to work on computer
science projects in a public institution (homeland security), a
start-up (wifirst), my own project (beouifi) and a large private
company, namely Amadeus.

Each environnement is different. Amadeus is an heavy organisation,
where each departement has a very specific attribution and has to
follow a precise guideline.

Interestingly enough, I have found in the DEV-ORI team some trends that
I used to believe to be limited to small companies, such as the
willing to release parts of its production in open source and an
appetite for a lot of new technologies such as cloud computing. I've
also been given time to focus on very specific topics such as the use
of SSE4 assembly instructions. As a consequence I believe that this
internship gave me a broader view of performance issues in software
design.


\end{document}
